;;; looking-glass-test.el --- Tests for looking-glass -*- lexical-binding: t; -*-

;;; Code:

(require 'ert)
(require 'looking-glass)

(cl-defstruct lg-test-person name age)

(ert-deftest lg-lens-basic-view-set-over ()
  (let ((optic (lg-nth 1)))
    (should (equal (lg-kind optic) 'lens))
    (should (equal (lg-view optic '(10 20 30)) 20))
    (should (equal (lg-set optic 99 '(10 20 30)) '(10 99 30)))
    (should (equal (lg-over optic (lambda (v) (+ v 1)) '(10 20 30))
                   '(10 21 30)))))

(ert-deftest lg-string-bool-char-table-lenses ()
  (should (equal (lg-over (lg-string-nth 1) (lambda (_c) ?X) "abcd")
                 "aXcd"))
  (should (equal (lg-ito-list-of (lg-istring-nth 2) "abcd")
                 '((2 . 99))))
  (let ((bv (bool-vector t nil t)))
    (should (equal (lg-over (lg-bool-vector-nth 1) (lambda (_v) t) bv)
                   (bool-vector t t t)))
    (should (equal (lg-ito-list-of (lg-ibool-vector-nth 0) bv)
                   '((0 . t)))))
  (let ((ct (make-char-table nil)))
    (aset ct ?a 10)
    (should (equal (lg-view (lg-char-table-char ?a) ct) 10))
    (should (equal (lg-ito-list-of (lg-ichar-table-char ?a) ct)
                   '((97 . 10))))))

(ert-deftest lg-alist-lens-and-traversals ()
  (let ((data '((x . 1) (y . 2) (x . 3))))
    (should (equal (lg-view (lg-alist 'x) data) 1))
    (should (equal (lg-over (lg-alist 'x) (lambda (v) (+ v 9)) data)
                   '((x . 10) (y . 2) (x . 3))))
    (should (equal (lg-to-list-of (lg-alist-values 'x) data)
                   '(1 3)))
    (should (equal (lg-ito-list-of (lg-ialist-values 'x) data)
                   '((x . 1) (x . 3))))
    (should (equal (lg-ito-list-of (lg-ialist 'y) data)
                   '((y . 2))))))

(ert-deftest lg-struct-slot-and-tree-leaves ()
  (let* ((person (make-lg-test-person :name "niall" :age 30))
         (optic (lg-struct-slot #'lg-test-person-age
                                (lambda (new p)
                                  (let ((copy (copy-lg-test-person p)))
                                    (setf (lg-test-person-age copy) new)
                                    copy))
                                'age)))
    (should (equal (lg-view optic person) 30))
    (should (equal (lg-ito-list-of optic person)
                   '((age . 30)))))
  (let ((tree '((1 . 2) . (3 . (4 . nil)))))
    (should (equal (lg-to-list-of (lg-tree-leaves #'numberp) tree)
                   '(1 2 3 4)))
    (should (equal (lg-ito-list-of (lg-itree-leaves #'numberp) tree)
                   '(((car car) . 1)
                     ((car cdr) . 2)
                     ((cdr car) . 3)
                     ((cdr cdr car) . 4))))))

(ert-deftest lg-indexed-constructor-forms ()
  (let* ((ig (lg-igetter (lambda (source) (cons :len (length source)))))
         (ifd (lg-ifold (lambda (_source) '((a . 1) (b . 2)))))
         (ist (lg-isetter (lambda (fn source)
                            (let ((i 0)
                                  (out nil))
                              (dolist (v source (nreverse out))
                                (push (funcall fn i v) out)
                                (setq i (1+ i))))))))
    (should (equal (lg-ito-list-of ig '(x y z))
                   '((:len . 3))))
    (should (equal (lg-ito-list-of ifd nil)
                   '((a . 1) (b . 2))))
    (should (equal (lg-iover ist
                             (lambda (idx v)
                               (if (= idx 0) (* 10 v) v))
                             '(1 2 3))
                   '(10 2 3)))))

(ert-deftest lg-compose-lens-traversal ()
  (let* ((optic (lg-compose (lg-nth 1) (lg-each-list)))
         (source '((a b) (1 2 3) (x y))))
    (should (equal (lg-kind optic) 'traversal))
    (should (equal (lg-to-list-of optic source) '(1 2 3)))
    (should (equal (lg-over optic (lambda (n) (* n 10)) source)
                   '((a b) (10 20 30) (x y))))))

(ert-deftest lg-prism-preview-review ()
  (let ((optic (lg-just)))
    (should (equal (lg-kind optic) 'prism))
    (should (equal (lg-preview optic 42) 42))
    (should (equal (lg-preview optic nil) nil))
    (should (equal (lg-review optic "ok") "ok"))))

(ert-deftest lg-regex-over-full-match ()
  (let ((optic (lg-regex "[0-9]+")))
    (should (equal (lg-to-list-of optic "a12-b34") '("12" "34")))
    (should (equal (lg-over optic (lambda (n) (format "[%s]" n)) "a12-b34")
                   "a[12]-b[34]"))))

(ert-deftest lg-regex-over-capture-group ()
  (let ((optic (lg-regex "\\([a-z]+\\)=\\([0-9]+\\)" 2)))
    (should (equal (lg-to-list-of optic "x=10,y=20") '("10" "20")))
    (should (equal (lg-over optic (lambda (n) (number-to-string (* 2 (string-to-number n))))
                           "x=10,y=20")
                   "x=20,y=40"))))

(ert-deftest lg-view-errors-on-non-single-focus ()
  (should-error (lg-view (lg-regex "[a-z]") "abc")))

(ert-deftest lg-kind-capabilities-inspection ()
  (let ((optic (lg-compose (lg-nth 1) (lg-each-list))))
    (should (equal (lg-kind optic) 'traversal))
    (should (lg-can-p optic 'over))
    (should (lg-can-p optic 'collect))
    (should (not (lg-can-p optic 'review)))))

(ert-deftest lg-profunctor-representation-composes ()
  (let* ((optic (lg-compose (lg-nth 1) (lg-each-list) (lg-just)))
         (rep (lg-optic-rep optic)))
    (should (functionp rep))
    (should (equal (lg-preview optic '((a) (1 2) nil)) 1))))

(ert-deftest lg-indexed-profunctor-representation-present ()
  (let ((optic (lg-ieach-list)))
    (should (functionp (lg-optic-rep optic)))
    (should (functionp (lg-optic-irep optic)))))

(ert-deftest lg-indexed-base-lenses-car-cdr ()
  (let ((cell '(10 . 20)))
    (should (equal (lg-ito-list-of lg-icar cell) '((car . 10))))
    (should (equal (lg-ito-list-of lg-icdr cell) '((cdr . 20))))
    (should (equal (lg-iover lg-icar (lambda (idx v)
                                       (if (eq idx 'car) (+ v 1) v))
                             cell)
                   '(11 . 20)))))

(ert-deftest lg-indexed-hash-and-plist-lenses ()
  (let ((table (make-hash-table :test #'equal)))
    (puthash "x" 10 table)
    (should (equal (lg-ito-list-of (lg-igethash "x") table)
                   '(("x" . 10))))
    (let ((updated (lg-iover (lg-igethash "x")
                             (lambda (idx v)
                               (if (equal idx "x") (+ v 5) v))
                             table)))
      (should (= (gethash "x" updated) 15))))
  (let ((plist '(:a 1 :b 2)))
    (should (equal (lg-ito-list-of (lg-iplist :b) plist)
                   '((:b . 2))))
    (should (equal (lg-iover (lg-iplist :b)
                             (lambda (idx v)
                               (if (eq idx :b) (* v 10) v))
                             plist)
                   '(:a 1 :b 20)))))

(ert-deftest lg-iregex-indexed-collection-and-over ()
  (let ((optic (lg-iregex "\\([a-z]+\\)=\\([0-9]+\\)" 2)))
    (should (equal (lg-ito-list-of optic "x=10,y=20,z=30")
                   '((0 . "10") (1 . "20") (2 . "30"))))
    (should (equal (lg-iover optic
                             (lambda (idx v)
                               (if (= idx 1)
                                   (number-to-string (* 3 (string-to-number v)))
                                 v))
                             "x=10,y=20,z=30")
                   "x=10,y=60,z=30"))))

(ert-deftest lg-ifiltered-replaces-index-when-guard ()
  (let* ((source '(10 20 30 40 50))
         (pairs (lg-ito-list-of (lg-ieach-list) source))
         (optic (lg-compose (lg-each-list)
                            (lg-ifiltered (lambda (idx _value)
                                            (= 0 (% idx 2)))))))
    (should (equal (lg-to-list-of optic pairs)
                   '((0 . 10) (2 . 30) (4 . 50))))))

(ert-deftest lg-indexed-traversal-collect-and-over ()
  (let ((optic (lg-ieach-list)))
    (should (equal (lg-kind optic) 'indexed-traversal))
    (should (equal (lg-ito-list-of optic '(a b c))
                   '((0 . a) (1 . b) (2 . c))))
    (should (equal (lg-iover optic
                             (lambda (i v)
                               (if (= i 1) (intern (format "%s!" v)) v))
                             '(a b c))
                   '(a b! c)))))

(ert-deftest lg-indexed-compose-propagates-path-index ()
  (let* ((optic (lg-compose (lg-ieach-list) (lg-ieach-list)))
         (source '((a b) (c d))))
    (should (equal (lg-kind optic) 'indexed-traversal))
    (should (equal (lg-ito-list-of optic source)
                   '(((0 . 0) . a) ((0 . 1) . b) ((1 . 0) . c) ((1 . 1) . d))))
    (should (equal (lg-iover optic
                             (lambda (idx v)
                               (if (equal idx '(1 . 0)) 'X v))
                             source)
                   '((a b) (X d))))))

(ert-deftest lg-indexed-compose-mixed-indexed-and-unindexed ()
  (let* ((optic (lg-compose (lg-ieach-list) (lg-each-list)))
         (source '((a b) (c d))))
    (should (equal (lg-kind optic) 'indexed-traversal))
    (should (equal (lg-ito-list-of optic source)
                   '((0 . a) (0 . b) (1 . c) (1 . d))))
    (should (equal (lg-iover optic
                             (lambda (idx v)
                               (if (= idx 0) (intern (format "%s0" v)) v))
                             source)
                   '((a0 b0) (c d))))))

(ert-deftest lg-review-only-optic ()
  (let ((optic (lg-reviewer (lambda (value) (list :wrapped value)))))
    (should (equal (lg-kind optic) 'review))
    (should (equal (lg-review optic 7) '(:wrapped 7)))
    (should-error (lg-over optic #'identity 1))))

(provide 'looking-glass-test)

;;; looking-glass-test.el ends here
